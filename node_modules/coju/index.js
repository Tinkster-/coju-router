{
  function coju() {
    this.middlewares = {};
    this.middlewareIndexesByName = {};

    this.options = {
      "debug"  : process.env.NODE_ENV === 'development',
      "events" : {
        "request"       : true,
        "close"         : true,
        "checkContinue" : true,
        "continue"      : true,
        "connect"       : true,
        "upgrade"       : true,
        "clientError"   : true
      }
    };
  }

  /**
   * Run a group of middleware and pass arguments.
   * 
   * @param  {string} group name to run
   * @param  {[type]} args  array of arguments to pass to middleware
   * @return {void}
   */
  coju.prototype.runMiddlewareGroup = function(group, args) {
    this.middlewares[group].forEach(function(middleware) {
      middleware.apply(middleware, args);
    });
  };

  /**
   * Subscribe middleware to server events.
   * 
   * @param  {String} server event.
   * @param {Function} Callback to add for this event.
   * @return {Number} Return index at which this middleware is stored at for removal later.
   */
  coju.prototype.on = function(eventName, callback) {
    // If this event hasn't been registered before, create the array.
    if (!this.middlewares.hasOwnProperty(eventName)) {
      this.middlewares[eventName] = [];
    }
    
    // Register the middleware.
    this.middlewares[eventName].push(callback);

    // Used more than once.
    let lngth = this.middlewares[eventName].length;

    // Does the callback have a name?
    if (callback.hasOwnProperty('name')) {
      this.middlewareIndexesByName[callback.name] = lngth;
    }

    // Return the index
    return lngth;
  };

  /**
   * Unsubscribe middleware from HTTP events
   * 
   * @param  {String} HTTP event.
   * @param {Function} Callback to remove for this event.
   * @return {void}
   */
  coju.prototype.off = function(eventName, callback) {
    // Check and error
    if (!callback.hasOwnProperty('name') && (typeof callback) !== 'number') {
      console.error('This callback cannot be removed from the middlewares stack.');
      console.error('To remove this middleware from the event stack, give the function a name or provide an array index.');
      return false;
    }

    // Get the index of this named callback.
    let index = this.middlewareIndexesByName[callback.name] - 1;

    // Remove this middleware
    if ((typeof callback) === 'number') {
      index = callback;
    }

    // Remove the middleware at the index
    this.middlewares[eventName].splice(index, 1);
    delete this.middlewareIndexesByName[callback.name];
  };

  /**
   * Disable/Enable certain features of coju
   * @param  {JSON} options - JSON object containing configuration
   * @return {void}
   */
  coju.prototype.configure = function(options) {
    for (let k in options) {
      if (this.options.hasOwnProperty(k)) {
        if (k === 'events') {
          for (let e in options.events) {
            if (this.options.events.hasOwnProperty(e)) {
              this.options.events[e] = options.events[e];
            }
          }
        } else {
          this.options = options[k];
        }
      }
    }
  };

  coju.prototype.runRequestMiddlewares = function(req, res) {
    let start;
    if (this.options.debug) {
      start = (new Date).getTime();
    }

    if (!this.middlewares.hasOwnProperty('request')) {
      return false;
    }

    this.runMiddlewareGroup('request', arguments);
    
    if (this.options.debug) {
      console.log(req.method.toUpperCase(), (new Date).getTime() - start + 'ms');
    }
  };

  coju.prototype.runConnectionMiddlewares = function(socket) {
    if (!this.middlewares.hasOwnProperty('connection')) {
      return false;
    }
    this.runMiddlewareGroup('connection', arguments);
  };

  coju.prototype.runCloseMiddlewares = function() {
    if (!this.middlewares.hasOwnProperty('close')) {
      return false;
    }
    this.runMiddlewareGroup('close', arguments);
  };

  coju.prototype.runCheckContinueMiddlewares = function(req, res) {
    if (!this.middlewares.hasOwnProperty('checkContinue')) {
      return false;
    }
    this.runMiddlewareGroup('checkContinue', arguments);
  };

  coju.prototype.runConnectMiddlewares = function(req, socket, head) {
    if (!this.middlewares.hasOwnProperty('continue')) {
      return false;
    }
    this.runMiddlewareGroup('continue', arguments);
  };

  coju.prototype.runUpgradeMiddlewares = function(req, socket, head) {
    if (!this.middlewares.hasOwnProperty('upgrade')) {
      return false;
    }
    this.runMiddlewareGroup('upgrade', arguments);
  };

  coju.prototype.runClientErrorMiddlewares = function(exception, socket) {
    if (!this.middlewares.hasOwnProperty('clientError')) {
      return false;
    }
    this.runMiddlewareGroup('clientError', arguments);
  };

  /**
   * Fires the server listen function as a proxy and sets up the 
   * base listeners.
   *
   * @link http://nodejs.org/docs/v0.11.11/api/http.html#http_server_listen_port_hostname_backlog_callback
   * @return {void}
   */
  coju.prototype.listen = function(port, isHttps) {
    let https = isHttps;
    let http = require(isHttps ? 'https' : 'http');
    let server = http.createServer();

    if (this.options.events.request)
      server.on('request', this.runRequestMiddlewares.bind(this));
    if (this.options.events.connection)
      server.on('connection', this.runConnectionMiddlewares.bind(this));
    if (this.options.events.close)
      server.on('close', this.runCloseMiddlewares.bind(this));
    if (this.options.events.checkContinue)
      server.on('checkContinue', this.runCheckContinueMiddlewares.bind(this));
    if (this.options.events.connect)
      server.on('connect', this.runConnectMiddlewares.bind(this));
    if (this.options.events.upgrade)
      server.on('upgrade', this.runUpgradeMiddlewares.bind(this));
    if (this.options.events.clientError)
      server.on('clientError', this.runClientErrorMiddlewares.bind(this));

    server.listen(port || process.env.PORT || 1811);

    return server;
  };

  module.exports = (function() {
      return new coju();
    })();
}